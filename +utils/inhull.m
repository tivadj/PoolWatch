function in = inhull(testpts,xyz,tess,tol)
% inhull: tests if a set of points are inside a convex hull
% usage: in = inhull(testpts,xyz)
% usage: in = inhull(testpts,xyz,tess)
% usage: in = inhull(testpts,xyz,tess,tol)
%
% arguments: (input)
% testpts - nxp array to test, n data points, in p dimensions
% If you have many points to test, it is most efficient to
% call this function once with the entire set.
%
% xyz - mxp array of vertices of the convex hull, as used by
% convhulln.
%
% tess - tessellation (or triangulation) generated by convhulln
% If tess is left empty or not supplied, then it will be
% generated.
%
% tol - (OPTIONAL) tolerance on the tests for inclusion in the
% convex hull
%
% DEFAULT: tol = 0
%
% arguments: (output)
% in - nx1 logical vector
% in(i) == 1 --> the i'th point was inside the convex hull.
% 
% Example usage: The first point should be inside, the second out
%
% xy = randn(20,2)
% tess = convhull(xy(:,1),xy(:,2));
% testpoints = [ 0 0; 10 10];
% in = inhull(testpts,xyz,tess)
%
% in = 
% 1
% 0
%
% See also: convhull, convhulln, delaunay, delaunayn, tsearch, tsearchn
%
% Author: John D'Errico
% Release: 1.0
% Release date: 3/4/06
 
% get array sizes
% m points, p dimensions
[m,p] = size(xyz);
[n,c] = size(testpts);
if p ~= c
  error 'testpts and xyz must have the same number of columns'
end
if p < 2
  error 'Points must lie in at least a 2-d space.'
end
 
% was the convex hull supplied?
if (nargin<3) || isempty(tess)
  tess = convhulln(xyz);
end
[nt,c] = size(tess);
if c ~= p
  error 'tess array is incompatible with a dimension p space'
end
 
% was tol supplied?
if (nargin<4) || isempty(tol)
  tol = 0;
end
 
% build normal vectors
switch p
  case 2
    % really simple for 2-d
    nrmls = (xyz(tess(:,1),:) - xyz(tess(:,2),:)) * [0 1;-1 0];
  case 3
    % use vectorized cross product for 3-d
    ab = xyz(tess(:,1),:) - xyz(tess(:,2),:);
    ac = xyz(tess(:,1),:) - xyz(tess(:,3),:);
    nrmls = cross(ab,ac,2);
  otherwise
    % slightly more work in higher dimensions, 
    nrmls = zeros(nt,p);
    for i = 1:nt
      nrmls(i,:) = null(xyz(tess(i,2:end),:) - repmat(xyz(tess(i,1),:),p-1,1))';
    end
end
 
% scale normal vectors to unit length
nrmllen = sqrt(sum(nrmls.^2,2));
nrmls = nrmls.*repmat(1./nrmllen,1,p);
 
% center point in the hull
center = mean(xyz,1);
 
% any point in the plane of each simplex in the convex hull
a = xyz(tess(:,1),:);
 
% ensure the normals are pointing inwards
dp = sum((repmat(center,nt,1) - a).*nrmls,2);
k = dp<0;
nrmls(k,:) = -nrmls(k,:);
 
% We want to test if: dot((x - a),N) >= 0
% If so for all faces of the hull, then x is inside
% the hull. Change this to dot(x,N) >= dot(a,N)
aN = sum(nrmls.*a,2);
 
% test, be careful in case there are many points
in = repmat(logical(0),n,1);
memblock = 1e7;
% if n is too large, we need to worry about the
% dot product grabbing huge chunks of memory.
blocks = max(1,floor(n/(memblock/nt)));
 
for i = 1:blocks
  j = i:blocks:n;
  in(j) = all((nrmls*testpts(j,:)' - repmat(aN,1,length(j))) >= -tol,1)';
end
